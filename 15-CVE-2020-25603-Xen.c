//  /usr/local/clang-4.0/bin/clang -emit-llvm -g -c  15-CVE-2020-25603-Xen.c  -o 15-CVE-2020-25603-Xen.bc
// Created by nsas2020 on 24-3-17.  (43,112) (98, 110)
//https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-25603
//https://xenbits.xen.org/xsa/advisory-340.html

#include <stdint.h>
#include <stdbool.h>

#include <stdlib.h>
#include <pthread.h>
#include <stdio.h>

#define UINT_MAX ((uint32_t)-1)
#define EVTCHNS_PER_GROUP 1024
#define EVTCHNS_PER_BUCKET 64
#define BUCKETS_PER_GROUP (EVTCHNS_PER_GROUP / EVTCHNS_PER_BUCKET)

typedef uint32_t evtchn_port_t;
typedef bool bool_t;

struct evtchn {
    int state;  // Placeholder for state
    int port;
};

struct domain {
    uint32_t max_evtchn_port;
    uint32_t max_evtchns;
    uint32_t valid_evtchns;
    struct evtchn **evtchn;
    struct evtchn **evtchn_group;
};

static inline void *xzalloc(size_t size) {
    void *ptr = malloc(size);
    if (!ptr) exit(EXIT_FAILURE); // Placeholder for error handling
    return ptr;
}

static inline bool port_is_valid(struct domain *d, unsigned int p) {
    if (p >= d->max_evtchns)
        return 0;
    return p < d->valid_evtchns;
    //smp_rmb();
}
typedef struct {
    struct domain *d;
    evtchn_port_t port;
} thread_data_t;

static inline struct evtchn *group_from_port(struct domain *d, unsigned int p) {
    return (struct evtchn *) &(d->evtchn_group[p / EVTCHNS_PER_GROUP]);
}

static inline struct evtchn *bucket_from_port(struct domain *d, unsigned int p) {
    unsigned int index = (p % EVTCHNS_PER_GROUP) / EVTCHNS_PER_BUCKET;

    // 直接通过索引返回桶的地址，减少中间变量的使用
    return (struct evtchn *) &(d->evtchn_group[index]);
}

size_t array_index_nospec(size_t index, size_t size) {
    // Ensure the index is within the bounds of the array
    if (index >= size) {
        // If not, force the index to a safe value
        index = size - 1;
    }
    return index;
}


struct evtchn *simple_alloc_evtchn(struct domain *d, evtchn_port_t port) {
    // 这里是一个示意性的简单分配逻辑
    struct evtchn *chn = malloc(sizeof(struct evtchn));
    if (!chn)
        return NULL;

    // 初始化分配的事件通道
    chn->port = 1;
    chn->state = -1; // 假设 ECS_FREE 是表示空闲状态的宏

    // 这里可以添加其他必要的初始化逻辑

    return chn;
}


static inline int evtchn_allocate_port(struct domain *d, evtchn_port_t port) {
    if (port > d->max_evtchn_port || port >= d->max_evtchns)
        return -1;




    if (port_is_valid(d, port)) {
        printf("1111\n");
        //if (evtchn_from_port(d, port)->state != 0)
        if (d->evtchn_group[port / EVTCHNS_PER_GROUP][port % EVTCHNS_PER_GROUP / EVTCHNS_PER_BUCKET].state != 0)
            return -2; // Placeholder for error code
    } else {
        printf("222\n");
        if (!group_from_port(d, port)) {
            struct evtchn **grp = calloc(BUCKETS_PER_GROUP, sizeof(struct evtchn *));
            if (!grp) return -3;
            d->evtchn_group[port / EVTCHNS_PER_GROUP] = *grp;
        }

        struct evtchn *chn = simple_alloc_evtchn(d, port);
        if (!chn) return -4;
        d->evtchn_group[port / EVTCHNS_PER_GROUP][port % EVTCHNS_PER_GROUP / EVTCHNS_PER_BUCKET] = *chn;
        // smp_wmb();
        d->valid_evtchns += EVTCHNS_PER_BUCKET;
    }
    return 0; // Placeholder for success code
}




struct domain *init_domain() {
    struct domain *d = malloc(sizeof(struct domain));
    if (!d) exit(EXIT_FAILURE);

    d->max_evtchn_port = UINT_MAX;
    d->max_evtchns = 2048;
    d->valid_evtchns = 5;
    d->evtchn = calloc(EVTCHNS_PER_GROUP, sizeof(struct evtchn *));
    d->evtchn_group = calloc(EVTCHNS_PER_GROUP, sizeof(struct evtchn **)); // 分配组


    if (!d->evtchn || !d->evtchn_group) exit(EXIT_FAILURE);

    for (unsigned int i = 0; i < EVTCHNS_PER_GROUP; ++i) {
        d->evtchn_group[i] = calloc(BUCKETS_PER_GROUP, sizeof(struct evtchn *)); // 为每个组分配桶
        if (!d->evtchn_group[i]) exit(EXIT_FAILURE);
    }
    return d;
}

// 线程函数
void *thread_func(void *arg) {
    thread_data_t *data = (thread_data_t *)arg;
    struct domain *d = data->d;
    evtchn_port_t port = data->port;

    int result = evtchn_allocate_port(d, port);
    printf("Thread %ld: result = %d\n", pthread_self(), result);

    free(data); // 记得清理分配的内存
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    struct domain *d = init_domain();

    // 为每个线程准备不同的数据
    thread_data_t *data1 = malloc(sizeof(thread_data_t));
    data1->d = d;
    data1->port = 4; // 假设这个值将导致执行if分支

    thread_data_t *data2 = malloc(sizeof(thread_data_t));
    data2->d = d;
    data2->port = 6; // 假设这个值将导致执行else分支

    // 创建两个线程，分别传入不同的数据
    if (pthread_create(&thread1, NULL, thread_func, data1)) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    if (pthread_create(&thread2, NULL, thread_func, data2)) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    // 等待线程结束
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    // 清理
    free(d->evtchn);
    free(d->evtchn_group);
    free(d);

    return 0;
}
//  /usr/local/clang-4.0/bin/clang -emit-llvm -g -c  15-CVE-2020-25603-Xen.c  -o 15-CVE-2020-25603-Xen.bc
// Created by nsas2020 on 24-3-17.  (43,112) (98, 110)
//https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-25603
//https://xenbits.xen.org/xsa/advisory-340.html

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdio.h>

#define UINT_MAX 100
#define EVTCHNS_NUMS 10

typedef uint32_t evtchn_port_t;
typedef bool bool_t;


struct domain {
    uint32_t max_evtchn_port;
    uint32_t valid_evtchns;
    int evtchn;
};

struct domain *d; // Global domain variable

static inline bool port_is_valid(unsigned int p) {
    return p < d->valid_evtchns;
}

typedef struct {
    evtchn_port_t port;
} thread_data_t;


static inline int evtchn_allocate_port(evtchn_port_t port) {
    if (port > d->max_evtchn_port)
        return -1;

    if (port_is_valid(port)) {
        printf("1111\n");
        if (d->evtchn == 0)
            return -2; // Placeholder for error code
    } else {
        printf("222\n");
        d->evtchn = 1 ;
        // smp_wmb();
        d->valid_evtchns += 1;
    }
    return 0; // Placeholder for success code
}

struct domain *init_domain() {
    d = malloc(sizeof(struct domain));
    if (!d) exit(EXIT_FAILURE);

    d->max_evtchn_port = UINT_MAX;
    d->valid_evtchns = 5;
    d->evtchn= -1; // Initialize state
    return d;
}

// 线程函数
void *thread_func(void *arg) {
    int port = (int) (uintptr_t) arg;

    int result = evtchn_allocate_port(port);
    printf("Thread %ld: result = %d\n", pthread_self(), result);

    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    d = init_domain();

    // 创建两个线程，分别传入不同的端口
    if (pthread_create(&thread1, NULL, thread_func, (void *) (uintptr_t) 4)) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    if (pthread_create(&thread2, NULL, thread_func, (void *) (uintptr_t) 6)) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    // 等待线程结束
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    // 清理
    free(d);
    return 0;
}

//  /usr/local/clang-4.0/bin/clang -emit-llvm -g -c  15-CVE-2020-25603-Xen.c  -o 15-CVE-2020-25603-Xen.bc
// Created by nsas2020 on 24-3-17.  (43,112) (98, 110)
//https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-25603
//https://xenbits.xen.org/xsa/advisory-340.html

#include <stdint.h>
#include <stdbool.h>
#include <assert.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdio.h>

#define UINT_MAX ((uint32_t)-1)
#define EVTCHNS_PER_GROUP 1024
#define EVTCHNS_PER_BUCKET 64
#define BUCKETS_PER_GROUP (EVTCHNS_PER_GROUP / EVTCHNS_PER_BUCKET)

typedef uint32_t evtchn_port_t;
typedef bool bool_t;

struct evtchn {
    int state;  // Placeholder for state
    int port;
};

struct domain {
    uint32_t max_evtchn_port;
    uint32_t max_evtchns;
    uint32_t valid_evtchns;
    struct evtchn **evtchn;
};

static inline bool port_is_valid(struct domain *d, unsigned int p) {
    if (p >= d->max_evtchns)
        return 0;
    return p < d->valid_evtchns;
    //smp_rmb();
}
typedef struct {
    struct domain *d;
    evtchn_port_t port;
} thread_data_t;


size_t array_index_nospec(size_t index, size_t size) {
    // Ensure the index is within the bounds of the array
    if (index >= size) {
        // If not, force the index to a safe value
        index = size - 1;
    }
    return index;
}


struct evtchn *simple_alloc_evtchn() {
    // 这里是一个示意性的简单分配逻辑
    struct evtchn *chn = malloc(sizeof(struct evtchn));
    if (!chn)
        return NULL;

    // 初始化分配的事件通道
    chn->port = 1;
    chn->state = 1; // 假设 ECS_FREE 是表示空闲状态的宏

    // 这里可以添加其他必要的初始化逻辑

    return chn;
}


static inline int evtchn_allocate_port(struct domain *d, evtchn_port_t port) {
    if (port > d->max_evtchn_port || port >= d->max_evtchns)
        return -1;

    if (port_is_valid(d, port)) {
        printf("1111\n");
        //if (evtchn_from_port(d, port)->state != 0)
        assert(d->evtchn[port / EVTCHNS_PER_GROUP]->state == 1);
        if (d->evtchn[port / EVTCHNS_PER_GROUP]->state == 0){
            return -2; // Placeholder for error code
        }
    } else {
        struct evtchn *chn = simple_alloc_evtchn();
        if (!chn) return -4;
        d->evtchn[port / EVTCHNS_PER_GROUP] = chn;
        // smp_wmb();
        d->valid_evtchns += EVTCHNS_PER_BUCKET;
    }
    return 0; // Placeholder for success code
}




struct domain *init_domain() {
    struct domain *d = malloc(sizeof(struct domain));
    if (!d) /*exit(EXIT_FAILURE);*/

    d->max_evtchn_port = UINT_MAX;
    d->max_evtchns = 2048;
    d->valid_evtchns = 5;
    d->evtchn = calloc(EVTCHNS_PER_GROUP, sizeof(struct evtchn *));

    if (!d->evtchn) /*exit(EXIT_FAILURE);*/
    return d;
}

// 线程函数
void *thread_func(void *arg) {
    thread_data_t *data = (thread_data_t *)arg;
    struct domain *d = data->d;
    evtchn_port_t port = data->port;

    int result = evtchn_allocate_port(d, port);
    printf("Thread %ld: result = %d\n", pthread_self(), result);

    free(data); // 记得清理分配的内存
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    struct domain *d = init_domain();

    // 为每个线程准备不同的数据
    thread_data_t *data1 = malloc(sizeof(thread_data_t));
    data1->d = d;
    data1->d->max_evtchns = 1024;
    data1->d->valid_evtchns = 0;
    data1->d->max_evtchn_port = 1024;
    data1->d->evtchn = malloc(data1->d->max_evtchns * sizeof(struct evtchn*));
    // 初始化每个evtchn指针为指向默认初始化的evtchn结构体的内存
    for (size_t i = 0; i < data1->d->max_evtchns; i++) {
        data1->d->evtchn[i] = malloc(sizeof(struct evtchn));
        data1->d->evtchn[i]->state = -1;
    }
    data1->port = 1; // 假设这个值将导致执行if分支

    thread_data_t *data2 = malloc(sizeof(thread_data_t));
    data2->d = d;
    data2->port = 1; // 假设这个值将导致执行else分支

    // 创建两个线程，分别传入不同的数据
    if (pthread_create(&thread1, NULL, thread_func, data1)) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    if (pthread_create(&thread2, NULL, thread_func, data2)) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    // 等待线程结束
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    // 清理
    free(d->evtchn);
    free(d);

    return 0;
}